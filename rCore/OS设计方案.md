# OS设计方案

## 前言

本文的目的是使用Rust语言去实现一个基于RISC-V架构的操作系统内核，利用Rust语言的关键特性使得操作系统内核具备线程安全的特性。该操作系统内核是一个具备了操作系统基础的核心机制的微内核，基于负责与硬件通信的SBI，包括引导程序、内核加载器bootloader、中断、内存、进程、线程、文件系统等模块。

本文首先对相关研究现状进行了分析，对于Rust语言、RISC-V架构及其汇编语言进行简要介绍；自上而下对阐述了整个内核架构的设计方案，在技术路线中给出了操作系统内和各个模块之间的关系与实现思路；然后对于操作系统内核进行了自下而上的实现，并给出了关键代码及其解释，最后经过细化的系统测试，验证功能的正确性。

本文基于Ubuntu操作系统和Rust工具链作为开发环境，使用Rust语言以及R。ISC-V架构的汇编语言的混合编程进行开发，利用QEMU虚拟机进行调试和测试所实现的操作系统内核功能。

### 背景

随着计算机的发展，计算设备由大型的超级计算机到普通的家用电脑，再到分布式的各种智能硬件，设备的大小越来越趋近于微型化。对于计算机上所承载的程序的开发，也由最初的机器语言，逐渐发展到了过程描述语言、面向对象语言。语言的不断抽象，在客观上降低了开发人员的开发难度，但却需要相比于低级语言更多的操作系统性能开销。且由于近年来摩尔定律几近失效，芯片性能增长放缓，使得设备的日益小型化的需要与程序设计语言的高度抽象化趋势之间的矛盾逐渐凸显。

目前的小型设备基本以运行不依托操作系统的简单程序为主，由于性能的限制无法构建完整的系统内核，并不能很好地支持高度抽象的编程语言，导致其普遍抽象程度不高，而且因为没有操作系统的支持，程序的运行很不稳定。目前小型设备亟需一个性能开销小、运行稳定的操作系统内核。

Rust语言作为一种高效、可靠的通用高级语言，拥有极高的性能，具有优秀的底层控制能力以及编译期计算能力，同时还保证了线程安全，可以轻松的集成其他语言，有较为完备的文档以及错误提示。由于其快速、跨平台、低资源占用的优点，十分适合作为操作系统内核的开发语言。对于Rust语言编写操作系统内核的可行性的研究，有助于拓展Rust语言对于嵌入式设备的应用场景，为将Rust语言的特性引入操作系统内核的研究打下基础。

经过对于国内外文献的查阅，发现目前对于操作系统内核的研究多集中在X86指令集架构的复杂内核，对于RISC-V精简指令集的研究基本集中在机器学习领域，而且由于资源受限多使用容器化技术来模拟Linux系统进行相关机器学习代码的实现，造成了额外的开销。

这一研究可以弥补计算机学界对RISC-V指令集架构操作系统内核研究的不足，并影响基于RISC-V的机器学习的研究。对于在运行资源较低的设备上构建操作系统内核的可行性的研究，有助于使小型化甚至微型设备更具智能性和拓展性。

同时相较于宏内核的复杂架构，较为简单的操作系统内核有助于帮助开发人员在底层逻辑上理解操作系统的调度方式。对高等院校操作系统课的教授方法也有一定的启示。

### 主要研究内容

本课题在总结优秀开发者社区内容的基础上，通过整理相关需求、设计系统框架、编写主体功能、进行移植与测试。实现了一个具有中断、内存管理、线程管理、进程管理、文件系统等基本功能的易于复现的模块化的操作系统内核，并测试整个系统机的鲁棒性，再将其移植入K210开发板中，从而使操作系统内核可以稳定运行在真实的生产环境中。

主要研究内容：

（1）  中断：接收到中断请求后判断中断类型，根据中断类型进行响应上下文的存，等待相关中断处理完成后恢复上下文。

（2）  内存管理：使用物理页帧分配器和动态内存分配器来完成物理内存的管理，再通过三级页表建立物理内存和虚拟内存间的映射，最后调用三级页表的接口以给程序提供实际可用的虚拟地址空间。

（3）  线程管理：由调线程度器统一管理线程池，在每次创建新线程或切换线程时先切换至调度线程 idle完成内核栈响应的操作，后切换至目的线程。

（4）  进程管理：创建用户程序模板，使每一个带main方法的Rust语言可以被编译成一个独立的可执行文件（ELF 文件）。为ELF 文件创建内存空间，创建内核栈和用户栈，以应对不同线程的不同请求（陷入内核的系统调用和无需陷入的普通调用）。维护内核栈来保持每一次中断操作系统切换至内核态前的进程上下文，以进行中断处理。

（5）  文件系统：为文件系统创建设备驱动后，读取已经打包的磁盘文件并进行文件系统初始化，初始化结束后即可加载用户程序。

（6）  交叉编译环境到真实环境的移植：通过串口通信工具，将操作系统内核从开发环境烧写到K210开发板上。

### 相关技术介绍

#### Rust语言

为了实现一个操作系统内核，就需要选择其实现的语言。一个高性能、高可靠性的程序开发语言可以使操作系统在开发过程中避开内存管理或数据表示底层细节的陷阱。Rust的语言具有丰富的类型系统和所有权模型[4]，可以保证线程安全以及内存安全。这种对操作系统层面的支持十分优秀，开发者在程序的开发过程中可以规避许多常见的崩溃或安全漏洞。

Rust区别与其他高级语言的特征在于其独特的内存管理方式，保证了其内存安全。该特点是：

（1）Rust语言对于超出其作用域的变量会自动释放。虽然各个语言都对于简单值类型的栈内存超出作用域后的自动释放逻辑。但对于堆内存在C++中需要手动释放，在Java中需要委托垃圾回收或者手写释放语句。这种垃圾回收并不是实时的，而且会影响性能，还容易引起有些开发者遗忘释放而造成的内存溢出等问题。而Rust语言无论对于占内存还是堆内存，超出作用域后都会自动释放[5]。Rust语言的该特点在兼顾了性能的同时有效的减少了代码中是发生内存泄露的隐患。

（2）Rust语言的所有权模型只允许一段内存被最后的变量名所拥有，之前声明过的变量名都失效，这在根本上解决禁止了同一个可变数据有多个变量引用的情况。也就是说一个变量如果作为参数进行了传递或赋值，那么它就自动地失去了所有权，如图。这从根本上杜绝了并发情况下的资源共享冲突。同时该操作在编译期就进行检查，在编译期就杜绝了空指针的问题。

![image-20210530231136855](资源文件/OS设计方案.assets/image-20210530231136855.png)

Rust语言在开发之初就考虑到了内存的安全问题，这对于使用该语言开发操作系统内核有着先天的优势。使用Rust语言可以赋能操作系统内核的开发，降低代码出现漏洞、崩溃或损坏的可能性，极大的减少后期维护的成本。

#### RISC-V体系架构

RISC(精简指令集计算机，Reduced Instruction Set Computer-RISC)作为一种新型结架构，目前已经迎来了第五个版本，即RISC-V。其作为一个最新诞生的开源的指令集架构，与其他闭源的指令集（如x86、ARM架构）不同。RISC-V属于一个开放非营利性质的基金会，该基金会负责谨慎而负责的发展该架构，同时其开源的特性使它的发展不受公司或者技术的影响。

![image-20210530231313918](资源文件/OS设计方案.assets/image-20210530231313918.png)

传统计算机体系结构是增量ISA（Instruction Set Architecture），这意味着新处理器不仅必须实现新的ISA扩展，还必须实现过去的所有扩展。其目的是为了保持向后的二进制兼容性，这样几十年前程序的二进制版本仍然可以在最新的处理器上正确运行。这个传统意味着传统架构的每个实现必须实现过去的扩展中的错误设计，即便它们不再有意义。

RISC-V与其他的闭源架构相比，最大的特点是模块化ISA。它最核心的是一个命名为RV32I的基础ISA，他是不会改变的。这为汇编语言、编译器、操作系统开发者提供了稳定的锚点。也就是说所有的扩展不必保持向后的二进制兼容性，所有的结指令都可以使用当前最优的设计，而不必继承过去的错误。这种模块化是设计使RISC-V具有了体积好小、能耗低的特点，这对于边缘计算设备至关重要。

#### Rust与RISC-V汇编语言的混合编程

Rust语言提供实验性质的模块级内联汇编支持，可以将RISC-V汇编代码很方便的加入到程序中去，而不需要安装额外的汇编语言编译器。相比于使用独立的汇编程序代码，内嵌汇编不需要额外的编译和链接步骤，使用起来更加便利。并且，内嵌汇编可以使用它所在作用域的变量以及函数。由于可以和Rust代码语句进行混合，使用内嵌汇编可以完成一些单纯使用Rust无法完成的任务。

和其他的汇编语言一样，RISC-V的汇编语言不只包括于处理器能直接理解的常规指令，还可以支持一些拓展指令。这些指令依托于精巧的使用一些常规指令完成实现。也就是伪指令。但与其他指令集架构不同。RISC-V有一个x0寄存器其值始终为0。大多的RISC-V伪指令依赖与x0寄存器实现。这种把一个计算器直接用编码为0的操作可以很方便地将许多常用指令（如转跳、返回、等于零时转移）做为指令从而简化整个RISC-V的指令级架构。

#### 经典微内核

在20世纪80年代中期，卡内基梅隆大学的研究人员开发出了一个名为Match的操作系统。该操作系统采用了微内核的技术，对整个操作系统内核进行了模块化设计。这种操作系统的设计思路是从内核中删除所有不必要的部分，而把它们当做系统级或用户级的程序来实现。通过这种设计产生的操作系统内核体积非常小。多年以来关于哪些应用应留在内核内，哪些应用可以在用户空间内实现，还没有完全的定论。不过通常微内核会提供一个最小的进程与内存管理和通信功能。如图就是一个典型的微内核架构。

![image-20210530231505372](资源文件/OS设计方案.assets/image-20210530231505372.png)



## 设计方案

要实现一个能支持多道程序处理能力的操作系统系统，那么就需要为多道程序的运行提供必要资源。一般来说，单个程序并不会占用CPU和I/O的全部资源，单个用户会同时运行多个程序。使用进程模块可以进程的切换，从而提高CPU的利用率。同时为了满足安全要求，应隔离每一个进程，为其开辟属于自己的虚拟内存空间，这一部分由内存模块负责。

进程的切换需要终止当前的进程，保存当前的状态，从内存或是外存中加载新的程序作为进程[10]。这就需要中断模块来进行进程上下文的保存于恢复，以及中断处理。实际上，现代操作系统是中断驱动的。如果没有用户需要响应、没有进程需要执行，没有I/O设备需要服务，那么操作系统会等待这些事件的发生。事件总是由中断引起的，而中断又分为不同的类型，如软件产生了中断、运行时出现的错误或用户程序的请求。对于每一种中断操作系统都会有相应的操作进行处理。这就需要中断模块的配合。

操作系统会在内存中同时存储多个进程的堆栈数据，但由于内存空间有限，不能容纳所有的数据[11]。所以需要将部分不必要的数据存储在磁盘中，在需要的时候通过内存模块的页表将进程使用的资源动态地加载到内存中。

操作系统必须保证足够的响应时间，这可以通过内核模块的页表进行虚拟内存映射来实现。这样做的好处是，一个运行中的进程无需全部加载至内存中，也就是在一定程度上用户可以运行比内存空间大的程序。同时，虚拟内存将物理内存和逻辑内存区分开，使开发人员不必受内存空间的束缚。

计算机需要在多种类型的介质中存储信息。每种存储介质都有其不同的特点。如访问速度、容量传输速度、访问方法等。文件是文件创建者定义的相关信息集合。通过文件系统，操作系统可以管理各种存储介质，并控制它们来实现文件这一概念。同时将文件组织成目录。当多个用户访问时，操作系统负责控制不同用户对不同文件的访问权限。

综上，本文设计的操作系统内核的整体架构如图。

![image-20210530232043627](资源文件/OS设计方案.assets/image-20210530232043627.png)



## 实验指导书的结构

| 实验编号 |   实验名称    | 主要内容                                                     | 依赖性           |
| :------: | :-----------: | ------------------------------------------------------------ | ---------------- |
|    0     | RV64 裸机应用 | 创建不依赖标准库的裸机应用，为开发操作系统内核打下基础       | 环境部署         |
|    1     |   中断处理    | 实现上下文的保存与恢复，中断类型的判断与处理                 | 0                |
|    2     |   物理内存    | 实现物理内存的动态分配，实现物理页表                         | 0，1             |
|    3     |   虚拟内存    | 实现从物理内存到虚拟内存到映射，使用多级虚拟页表，实现内核重映射 | 0，1，2          |
|    4     |  进程与线程   | 抽象出线程与进程的概念，实现线程的创建、切换与结束，实现内核栈，实现线程的调度 | 0，1，2，3       |
|    5     |   文件系统    | 在抽象出驱动的基础上，将块设备托管给文件系统                 | 0，1，2，3，4    |
|    6     |   用户进程    | 将ELF格式的用户程序打包进文件系统中，并实现用户进程的创建与运行 | 0，1，2，3，4，5 |